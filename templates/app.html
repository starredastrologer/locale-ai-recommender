<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finding your spot... | Localƒì</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="app-container">
        <input type="hidden" id="initial-query" value="{{ session.get('initial_query', '') }}">

        <!-- Location Prompt Screen -->
        <div id="location-container" class="state-container active">
            <div class="logo">L</div>
            <h2>Let's Find Your Location üåç</h2>
            <p class="prompt-text">To discover the best spots near you, please grant location access when your browser asks.</p>
            <button id="grant-location-button" class="primary-action-button">Grant Location Access</button>
        </div>

        <!-- Distance Selection Screen -->
        <div id="distance-container" class="state-container">
            <div class="logo">L</div>
            <h2>How far are you willing to travel? üöó</h2>
            <p class="prompt-text">Select an estimated travel time.</p>
            <div class="distance-options">
                <button class="distance-button" data-distance="1500">~10 mins</button>
                <button class="distance-button" data-distance="4000">~20 mins</button>
                <button class="distance-button" data-distance="8000">~30 mins</button>
                <button class="distance-button" data-distance="15000">~1 hour</button>
                <button class="distance-button" data-distance="30000">~2 hours</button>
            </div>
        </div>

        <!-- Loading Screen -->
        <div id="loading-container" class="state-container">
            <div class="logo">L</div>
            <h2 id="loading-text">Consulting the cosmos... ‚ú®</h2>
            <div class="spinner"></div>
        </div>

        <!-- Results Screen -->
        <div id="results-container" class="state-container">
            <!-- This structure is new to support the mobile layout -->
            <h2 class="results-header">Voil√†! Here's what I found ü™Ñ</h2>
            <div id="cards-wrapper"></div>
            <div class="results-feedback">
                <button id="refine-button">ü§î Refine This Search</button>
                <button id="restart-button">üîÑ Start a New Search</button>
            </div>
        </div>

        <!-- Feedback Screen (Chat UI) -->
        <div id="feedback-container" class="state-container">
            <div id="chat-history"></div>
            <form id="feedback-form">
                <input type="text" id="feedback-input" placeholder="e.g., something cheaper or with outdoor seating...">
                <button type="submit">‚Üí</button>
            </form>
        </div>

        <!-- Error Screen -->
        <div id="error-container" class="state-container">
            <h2>Uh oh... ‚ö†Ô∏è</h2>
            <p id="error-message" class="error-text">An unknown error occurred.</p>
            <a href="/" class="restart-button">Try Again</a>
        </div>
    </div>

    <!-- JAVASCRIPT LOGIC - EMBEDDED IN HTML -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // State management
            const states = ['location', 'distance', 'loading', 'results', 'feedback', 'error'];
            const appState = {
                location: null,
                currentRecommendations: null
            };

            function showState(stateName, data = {}) {
                states.forEach(s => document.getElementById(`${s}-container`).classList.remove('active'));
                const container = document.getElementById(`${stateName}-container`);
                if (container) {
                    container.classList.add('active');
                    if (stateName === 'error') {
                        document.getElementById('error-message').textContent = data.message || 'An unexpected error occurred. Please try again.';
                    }
                    if (stateName === 'loading') {
                        const messages = ["Consulting the cosmos... ‚ú®", "Analyzing local vibes... üì°", "Asking the AI for its top picks... ü§ñ", "Cross-referencing reviews... üßê", "Finding hidden gems... üíé"];
                        document.getElementById('loading-text').textContent = messages[Math.floor(Math.random() * messages.length)];
                    }
                }
            }

            // --- API Communication ---
            async function fetchRecommendations(body) {
                try {
                    const response = await fetch('/get_recommendation', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(body),
                    });
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error("Fetch error:", error);
                    showState('error', { message: 'Could not connect to the server. Please check your connection and try again.' });
                }
            }
            
            // --- UI Rendering ---
            function createRecommendationCard(place) {
                const card = document.createElement('div');
                card.className = 'recommendation-card';
                
                const mainPhoto = place.photo_urls && place.photo_urls.length > 0 
                    ? place.photo_urls[0] 
                    : 'https://via.placeholder.com/350x200/181818/B3B3B3?text=No+Image+Available';

                // IMPROVEMENT 2: Review is now in a dropdown
                const reviewText = place.reviews && place.reviews.length > 0 ? place.reviews[0] : 'No reviews available to show.';
                const reviewHtml = `
                    <div class="card-review">
                        <details>
                            <summary>Show top review</summary>
                            <p>"${reviewText}"</p>
                        </details>
                    </div>
                `;

                const bookmarks = JSON.parse(localStorage.getItem('bookmarks')) || {};
                const isBookmarked = bookmarks[place.place_id] ? 'bookmarked' : '';

                card.innerHTML = `
                    <button class="bookmark-btn ${isBookmarked}" data-place-id="${place.place_id}">‚ô°</button>
                    <img src="${mainPhoto}" alt="${place.name}" class="card-photo">
                    <h3 class="card-title">${place.name}</h3>
                    <p class="card-rating">‚≠ê ${place.rating || 'N/A'} (${place.user_ratings_total || 0} ratings)</p>
                    <p class="travel-time">üöó ${place.travel_time || 'Travel time not available'}</p>
                    ${reviewHtml}
                    <a href="${place.link}" target="_blank" class="card-link">View on Google Maps</a>
                `;
                
                // Add bookmark functionality
                card.querySelector('.bookmark-btn').addEventListener('click', (e) => toggleBookmark(e, place));

                return card;
            }

            function displayResults(data) {
                appState.currentRecommendations = data;
                const wrapper = document.getElementById('cards-wrapper');
                wrapper.innerHTML = '';
                if (data && data.recommendations && data.recommendations.length > 0) {
                    data.recommendations.forEach(place => {
                        const card = createRecommendationCard(place);
                        wrapper.appendChild(card);
                    });
                    showState('results');
                    saveToHistory(data);
                } else {
                    showState('error', { message: "Couldn't find any recommendations matching your criteria. Please try a different search." });
                }
            }

            // --- Local Storage ---
            function toggleBookmark(event, placeData) {
                event.stopPropagation();
                const btn = event.currentTarget;
                const placeId = btn.dataset.placeId;
                let bookmarks = JSON.parse(localStorage.getItem('bookmarks')) || {};
                if (bookmarks[placeId]) {
                    delete bookmarks[placeId];
                    btn.classList.remove('bookmarked');
                } else {
                    bookmarks[placeId] = placeData;
                    btn.classList.add('bookmarked');
                }
                localStorage.setItem('bookmarks', JSON.stringify(bookmarks));
            }

            function saveToHistory(data) {
                let history = JSON.parse(localStorage.getItem('searchHistory')) || [];
                history.push(data);
                if (history.length > 10) history.shift(); // Keep only last 10 searches
                localStorage.setItem('searchHistory', JSON.stringify(history));
            }

            // --- Event Handlers & Initial Flow ---
            document.getElementById('grant-location-button').addEventListener('click', () => {
                if (!navigator.geolocation) {
                    showState('error', { message: 'Geolocation is not supported by your browser.' });
                    return;
                }
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        appState.location = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude,
                        };
                        showState('distance');
                    },
                    () => showState('error', { message: 'Location access was denied. This app requires your location to find nearby places.' })
                );
            });

            document.querySelectorAll('.distance-button').forEach(button => {
                button.addEventListener('click', async () => {
                    showState('loading');
                    const initialQuery = document.getElementById('initial-query').value;
                    const body = {
                        query: initialQuery,
                        location: appState.location,
                        distance: button.dataset.distance,
                        is_feedback: false
                    };
                    const response = await fetchRecommendations(body);
                    handleApiResponse(response);
                });
            });
            
            document.getElementById('refine-button').addEventListener('click', () => {
                const historyDiv = document.getElementById('chat-history');
                historyDiv.innerHTML = `Your last search was for: <br><strong>"${appState.currentRecommendations.last_keyword}"</strong><br><br>How would you like to refine it?`;
                showState('feedback');
            });

            document.getElementById('feedback-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const input = document.getElementById('feedback-input');
                const feedbackQuery = input.value.trim();
                if (!feedbackQuery) return;
                
                showState('loading');
                const body = {
                    query: feedbackQuery,
                    location: appState.location,
                    is_feedback: true,
                };
                input.value = '';
                const response = await fetchRecommendations(body);
                handleApiResponse(response);
            });
            
            document.getElementById('restart-button').addEventListener('click', () => window.location.href = '/');

            function handleApiResponse(response) {
                if (!response) return; // Error already handled by fetchRecommendations
                switch(response.type) {
                    case 'recommendation':
                        displayResults(response.data);
                        break;
                    case 'question':
                        showState('feedback');
                        document.getElementById('chat-history').textContent = response.content;
                        break;
                    case 'expand_search':
                        // For simplicity in this refactor, we can treat this as an error for now
                        // or create a dedicated state for it.
                        showState('error', { message: response.message + ' Would you like to try a new search?' });
                        break;
                    case 'final_message':
                        showState('error', { message: response.content });
                        break;
                    default:
                        showState('error', { message: response.content || 'An unknown error occurred.' });
                        break;
                }
            }

        });
    </script>
</body>
</html>
